# === Robust Parser for Inline (index,value) CSV → TSV (thousands-safe, no-space-before-index-safe) ===
# Fixes:
# - Correctly ignores thousands separators like "20,000" inside values
# - Recognizes pairs even when the index is glued after punctuation, e.g. ")90,2025/6/30"
# Output per section (e.g., "ASSET ...", "TRANSACTION ..."):
#   header
#   value1 \t value2 \t value3 ...

import re, datetime
from typing import List, Tuple
import ipywidgets as w
from IPython.display import display, HTML

# Improved pair-start pattern:
# 1) Left boundary: start-of-string OR the previous char is NOT a digit/letter/=/./%
# 2) Index: 1–3 digits
# 3) Comma
# 4) Negative lookahead: NOT followed by exactly 3 digits then a non-digit or end (avoid thousands groups)
PAIR_START_RE = re.compile(r'(?:(?<![\dA-Za-z=.%])|^)(\d{1,3}),(?!\d{3}(?:\D|$))')

# A header line: does NOT start with "digits,"
HEADER_RE = re.compile(r'^\s*(?!\d+,).+?$')

def normalize_text(s: str) -> str:
    s = s.replace("\r\n", "\n").replace("\r", "\n").strip()
    # strip markdown fences if present
    s = re.sub(r"^\s*```[a-zA-Z]*\s*\n", "", s)
    s = re.sub(r"\n\s*```$", "", s)
    return s

def split_sections(raw: str) -> List[Tuple[str, str]]:
    """Split input into (header, content) sections."""
    lines = [ln for ln in normalize_text(raw).split("\n") if ln.strip() != ""]
    sections, header, buffer = [], None, []

    def flush():
        nonlocal header, buffer
        if header is not None:
            sections.append((header, " ".join(buffer).strip()))
        header, buffer = None, []

    for ln in lines:
        if HEADER_RE.match(ln):
            flush()
            header = ln.strip()
        else:
            buffer.append(ln.strip())
    flush()
    return sections

def parse_pairs(content: str) -> List[Tuple[str, str]]:
    """
    Extract (index, value) pairs from a single-line or multi-line content block.
    The regex anchors are thousand-safe and allow no-space prefixes like ')90,'.
    """
    content = content.strip()
    anchors = list(PAIR_START_RE.finditer(content))
    if not anchors:
        return []

    pairs = []
    for i, m in enumerate(anchors):
        idx = m.group(1)
        start = m.end()
        end = anchors[i+1].start() if i+1 < len(anchors) else len(content)
        val = content[start:end].strip()
        # keep inner commas, quotes, JP text; just make TSV-safe
        val = val.replace("\t", " ").replace("\n", " ")
        val = re.sub(r'\s{2,}', ' ', val)
        pairs.append((idx, val))
    return pairs

def section_to_tsv_lines(header: str, content: str) -> List[str]:
    pairs = parse_pairs(content)
    # numeric sort if possible
    try:
        pairs.sort(key=lambda kv: int(kv[0]))
    except Exception:
        pass
    values = [v for _, v in pairs]
    return [header, "\t".join(values)]

# --- Colab UI ---

inp = w.Textarea(
    value="",
    placeholder="Paste your content (e.g., section header lines followed by '1,val 2,val ...').",
    description="Input",
    layout=w.Layout(width="100%", height="280px"),
)

excel_mode = w.Checkbox(value=False, description="Excel-friendly (UTF-16)")
btn = w.Button(description="Convert", button_style="primary")
tsv_area = w.Textarea(
    value="",
    placeholder="TSV result appears here. Copy & paste into Excel.",
    description="TSV",
    layout=w.Layout(width="100%", height="240px"),
)
download_btn = w.Button(description="Download .tsv", disabled=True)
out = w.Output()

def on_convert(_):
    out.clear_output()
    tsv_area.value = ""
    try:
        sections = split_sections(inp.value)
        lines = []
        for header, content in sections:
            lines.extend(section_to_tsv_lines(header, content))
        tsv_text = "\n".join(lines)
        tsv_area.value = tsv_text

        fname = f"converted_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.tsv"
        if excel_mode.value:
            with open(fname, "w", encoding="utf-16") as f:
                f.write(tsv_text)
        else:
            with open(fname, "w", encoding="utf-8") as f:
                f.write(tsv_text)
        download_btn.description = f"Download {fname}"
        download_btn._filename = fname
        download_btn.disabled = False

        with out:
            display(HTML("<b>Done.</b> TSV text generated; copy or download."))
    except Exception as e:
        with out:
            display(HTML(f"<span style='color:red'>Error: {e}</span>"))

def on_download(_):
    try:
        from google.colab import files
        files.download(download_btn._filename)
    except Exception as e:
        with out:
            display(HTML(f"<span style='color:red'>Download error: {e}</span>"))

btn.on_click(on_convert)
download_btn.on_click(on_download)

display(HTML("<h3>Enhanced Inline CSV → TSV Converter</h3>"
             "<p>Thousand-safe and recognizes indices without preceding spaces (e.g., ')90,').</p>"))
display(inp, w.HBox([btn, excel_mode]), tsv_area, w.HBox([download_btn]), out)
